filename,name,text,summary
1.1-directory-content-tracking, "Repository: Directory content tracking", "As mentioned above, what Git does is quite rudimentary: it maintains snapshots of a directory’s contents. Much of its internal design can be understood in terms of this basic task.",
1.2-introducing-the-blob, "Introducing the blob", "Now that the basic picture has been painted, let’s get into some practical examples. I’m going to start by creating a sample Git repository, and showing how Git works from the bottom up in that repository. Feel free to follow along as you read:",
1.3-blobs-are-stored-in-trees, "Blobs are stored in trees", "The contents of your files are stored in blobs, but those blobs are pretty featureless. They have no name, no structure — they’re just “blobs”, after all.",
1.4-how-trees-are-made, "How trees are made", "Every commit holds a single tree, but how are trees made? We know that blobs are created by stuffing the contents of your files into blobs — and that trees own blobs — but we haven’t yet seen how the tree that holds the blob is made, or how that tree gets linked to its parent commit.",
1.5-the-beauty-of-commits,"The beauty of commits","Some version control systems make “branches” into magical things, often distinguishing them from the “main line” or “trunk”, while others discuss the concept as though it were very different from commits. But in Git there are no branches as separate entities: there are only blobs, trees and commits. Since a commit can have one or more parents, and those commits can have parents, this is what allows a single commit to be treated like a branch: because it knows the whole history that led up to it.",
1.6-a-commit-by-any-other-name,"A commit by any other name...","Understanding commits is the key to grokking Git. You’ll know you have reached the Zen plateau of branching wisdom when your mind contains only commit topologies, leaving behind the confusion of branches, tags, local and remote repositories, etc. Hopefully such understanding will not require lopping off your arm — although I can appreciate if you’ve considered it by now.",
1.7-branching-and-the-power-of-rebase,"Branching and the power of rebase","One of Git’s most capable commands for manipulating commits is the innocently-named rebase command. Basically, every branch you work from has one or more “base commits”: the commits that branch was born from. Take the following typical scenario, for example. Note that the arrows point back in time because each commit references its parent(s), but not its children. Therefore, the D and Z commits represent the heads of their respective branches:",
1.8-interactive-rebasing,"Interactive rebasing","When rebase was run above, it automatically rewrote all the commits from `W` to `Z` in order to rebase the `Z` branch onto the `D` commit (i.e., the head commit of the `D` branch). You can, however, take complete control over how this rewriting is done. If you supply the `-i` option to `rebase`, it will pop you into an editing buffer where you can choose what should be done for every commit in the local `Z` branch:",
2.1-meet-the-middle-man,"The Index: Meet the middle man","Between your data files, which are stored on the filesystem, and your Git blobs, which are stored in the repository, there stands a somewhat strange entity: the Git index. Part of what makes this beast hard to understand is that it’s got a rather unfortunate name. It’s an index in the sense that it refers to the set of newly created trees and blobs which you created by running add. These new objects will soon get bound into a new tree for the purpose of committing to your repository — but until then, they are only referenced by the index. That means that if you unregister a change from the index with reset, you’ll end up with an orphaned blob that will get deleted at some point at the future.",
2.2-taking-the-index-further,"Taking the index further","Let’s see, the index... With it you can pre-stage a set of changes, thus iteratively building up a patch before committing it to the repository. Now, where have I heard that concept before...",
3.1-to-reset-or-not-to-reset,"To reset, or not to reset","One of the more difficult commands to master in Git is `reset`, which seems to bite people more often than other commands. Which is understandable, giving that it has the potential to change both your working tree and your current HEAD reference. So I thought a quick review of this command would be useful.",
3.2-doing-a-mixed-reset,"Doing a mixed reset","If you use the `--mixed` option (or no option at all, as this is the default), reset will revert parts of your index along with your HEAD reference to match the given commit. The main difference from `--soft` is that `--soft` only changes the meaning of HEAD and doesn’t touch the index.",
3.3-doing-a-soft-reset,"Doing a soft reset","If you use the `--soft` option to `reset`, this is the same as simply changing your HEAD reference to a different commit. Your working tree changes are left untouched. This means the following two commands are equivalent:",
3.4-doing-a-hard-reset,"Doing a hard reset","A hard reset (the `--hard` option) has the potential of being very dangerous, as it’s able to do two different things at once: First, if you do a hard reset against your current HEAD, it will erase all changes in your working tree, so that your current files match the contents of HEAD.",
4-Stashing-and-the-reflog,"Stashing and the reflog","Until now we’ve described two ways in which blobs find their way into Git: first they’re created in your index, both without a parent tree and without an owning commit; and then they’re committed into the repository, where they live as leaves hanging off of the tree held by that commit. But there are two other ways a blob can dwell in your repository.",
5-Conclusion,"Conclusion","Over the years I’ve used many version control systems, and many backup schemes. They all have facilities for retrieving the past contents of a file. Most of them have ways to show how a file has differed over time. Many permit you to go back in time, begin a divergent line of reasoning, and then later bring these new thoughts back to the present. Still fewer offer fine-grained control over that process, allowing you to collect your thoughts however you feel best to present your ideas to the public. Git lets you do all these things, and with relative ease — once you understand its fundamentals.",
6-Further-Reading,"Further reading","If your interest to learn Git more has been piqued, please check out the following articles:",
